/**
 * „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊ∏¨ÂÆö„Çπ„ÇØ„É™„Éó„Éà
 * Êó¢Â≠òÊ©üËÉΩ„Å®Êñ∞„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂàÜÊûê
 */

class PerformanceTester {
    constructor() {
        this.metrics = {
            pageLoad: {},
            sectionRender: {},
            dataLoading: {},
            interactions: {},
            resources: {},
            memory: {}
        };
        this.benchmarks = {
            pageLoad: 3000, // 3Áßí‰ª•ÂÜÖ
            sectionRender: 100, // 100ms‰ª•ÂÜÖ
            dataLoad: 500, // 500ms‰ª•ÂÜÖ
            interaction: 50, // 50ms‰ª•ÂÜÖ
            memory: 0.8 // „Éí„Éº„ÉóÂà∂Èôê„ÅÆ80%‰ª•ÂÜÖ
        };
    }

    /**
     * ÂÖ®„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„ÉàÂÆüË°å
     */
    async runPerformanceTests() {
        console.log('‚ö° „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„ÉàÈñãÂßã');
        console.log('='.repeat(50));

        try {
            // 1. „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊÄßËÉΩ
            await this.measurePageLoadPerformance();
            
            // 2. „Çª„ÇØ„Ç∑„Éß„É≥Ë°®Á§∫ÊÄßËÉΩ
            await this.measureSectionRenderPerformance();
            
            // 3. „Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÊÄßËÉΩ
            await this.measureDataLoadingPerformance();
            
            // 4. „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥ÊÄßËÉΩ
            await this.measureInteractionPerformance();
            
            // 5. „É™„ÇΩ„Éº„Çπ‰ΩøÁî®Èáè
            await this.measureResourceUsage();
            
            // 6. „É°„É¢„É™‰ΩøÁî®Èáè
            await this.measureMemoryUsage();
            
            // „É¨„Éù„Éº„ÉàÁîüÊàê
            this.generatePerformanceReport();
            
        } catch (error) {
            console.error('‚ùå „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà‰∏≠„Å´„Ç®„É©„Éº:', error);
        }

        return this.metrics;
    }

    /**
     * 1. „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊÄßËÉΩÊ∏¨ÂÆö
     */
    async measurePageLoadPerformance() {
        console.log('üìä 1. „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊÄßËÉΩÊ∏¨ÂÆö');

        // Navigation Timing API‰ΩøÁî®
        const navigation = performance.getEntriesByType('navigation')[0];
        if (navigation) {
            this.metrics.pageLoad = {
                // DNSËß£Ê±∫ÊôÇÈñì
                dnsLookup: Math.round(navigation.domainLookupEnd - navigation.domainLookupStart),
                
                // TCPÊé•Á∂öÊôÇÈñì
                tcpConnect: Math.round(navigation.connectEnd - navigation.connectStart),
                
                // „Çµ„Éº„Éê„Éº„É¨„Çπ„Éù„É≥„ÇπÊôÇÈñì
                serverResponse: Math.round(navigation.responseStart - navigation.requestStart),
                
                // HTMLËß£ÊûêÊôÇÈñì
                domParse: Math.round(navigation.domContentLoadedEventEnd - navigation.responseEnd),
                
                // „É™„ÇΩ„Éº„ÇπË™≠„ÅøËæº„ÅøÊôÇÈñì
                resourceLoad: Math.round(navigation.loadEventStart - navigation.domContentLoadedEventEnd),
                
                // Á∑èË™≠„ÅøËæº„ÅøÊôÇÈñì
                totalLoad: Math.round(navigation.loadEventEnd - navigation.fetchStart),
                
                // First Contentful Paint
                fcp: this.getFirstContentfulPaint(),
                
                // Largest Contentful Paint
                lcp: this.getLargestContentfulPaint()
            };

            console.log(`  DNSËß£Ê±∫: ${this.metrics.pageLoad.dnsLookup}ms`);
            console.log(`  „Çµ„Éº„Éê„Éº„É¨„Çπ„Éù„É≥„Çπ: ${this.metrics.pageLoad.serverResponse}ms`);
            console.log(`  Á∑èË™≠„ÅøËæº„ÅøÊôÇÈñì: ${this.metrics.pageLoad.totalLoad}ms`);
            console.log(`  FCP: ${this.metrics.pageLoad.fcp}ms`);
            console.log(`  LCP: ${this.metrics.pageLoad.lcp}ms`);
        } else {
            console.log('  ‚ö†Ô∏è  Navigation Timing APIÂà©Áî®‰∏çÂèØ');
        }
    }

    /**
     * 2. „Çª„ÇØ„Ç∑„Éß„É≥Ë°®Á§∫ÊÄßËÉΩÊ∏¨ÂÆö
     */
    async measureSectionRenderPerformance() {
        console.log('üìä 2. „Çª„ÇØ„Ç∑„Éß„É≥Ë°®Á§∫ÊÄßËÉΩÊ∏¨ÂÆö');

        const sections = document.querySelectorAll('section, .section, .hero-section, .tips-section');
        this.metrics.sectionRender = {};

        sections.forEach((section, index) => {
            const startTime = performance.now();
            
            // „Çª„ÇØ„Ç∑„Éß„É≥„ÅÆË°®Á§∫Âá¶ÁêÜ„Çí„Ç∑„Éü„É•„É¨„Éº„Éà
            const rect = section.getBoundingClientRect();
            const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
            const computedStyle = window.getComputedStyle(section);
            
            const endTime = performance.now();
            const renderTime = endTime - startTime;

            const sectionName = section.className || section.tagName.toLowerCase() || `section-${index}`;
            this.metrics.sectionRender[sectionName] = {
                renderTime: Math.round(renderTime * 100) / 100,
                isVisible,
                width: rect.width,
                height: rect.height,
                hasBackground: computedStyle.backgroundColor !== 'rgba(0, 0, 0, 0)',
                status: renderTime < this.benchmarks.sectionRender ? 'PASS' : 'FAIL'
            };

            console.log(`  ${sectionName}: ${renderTime.toFixed(2)}ms ${isVisible ? '(Ë°®Á§∫‰∏≠)' : '(ÈùûË°®Á§∫)'}`);
        });
    }

    /**
     * 3. „Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÊÄßËÉΩÊ∏¨ÂÆö
     */
    async measureDataLoadingPerformance() {
        console.log('üìä 3. „Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÊÄßËÉΩÊ∏¨ÂÆö');

        const dataFiles = [
            'Âá∫„Åó„Çè„ÅëSS - region.csv',
            'Âá∫„Åó„Çè„ÅëSS - ranking.csv',
            'Âá∫„Åó„Çè„ÅëSS - stores.csv',
            'Âá∫„Åó„Çè„ÅëSS - items.csv',
            'Âá∫„Åó„Çè„ÅëSS - store_view.csv'
        ];

        this.metrics.dataLoading = {};

        for (const fileName of dataFiles) {
            try {
                const startTime = performance.now();
                const response = await fetch(`./data/${fileName}`);
                const loadEndTime = performance.now();
                
                if (response.ok) {
                    const text = await response.text();
                    const parseEndTime = performance.now();
                    
                    const loadTime = loadEndTime - startTime;
                    const parseTime = parseEndTime - loadEndTime;
                    const totalTime = parseEndTime - startTime;

                    this.metrics.dataLoading[fileName] = {
                        loadTime: Math.round(loadTime),
                        parseTime: Math.round(parseTime),
                        totalTime: Math.round(totalTime),
                        fileSize: text.length,
                        lines: text.split('\n').length,
                        status: totalTime < this.benchmarks.dataLoad ? 'PASS' : 'FAIL'
                    };

                    console.log(`  ${fileName}: Ë™≠„ÅøËæº„Åø${loadTime.toFixed(0)}ms + Ëß£Êûê${parseTime.toFixed(0)}ms = ${totalTime.toFixed(0)}ms`);
                } else {
                    console.log(`  ${fileName}: ‚ùå Ë™≠„ÅøËæº„ÅøÂ§±Êïó (${response.status})`);
                }
            } catch (error) {
                console.log(`  ${fileName}: ‚ùå „Ç®„É©„Éº - ${error.message}`);
                this.metrics.dataLoading[fileName] = {
                    error: error.message,
                    status: 'ERROR'
                };
            }
        }
    }

    /**
     * 4. „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥ÊÄßËÉΩÊ∏¨ÂÆö
     */
    async measureInteractionPerformance() {
        console.log('üìä 4. „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥ÊÄßËÉΩÊ∏¨ÂÆö');

        const interactions = [
            {
                name: 'Âú∞ÂüüÈÅ∏Êäû',
                element: document.getElementById('region-select'),
                event: 'change'
            },
            {
                name: '„É©„É≥„Ç≠„É≥„Ç∞È†ÖÁõÆ„ÇØ„É™„ÉÉ„ÇØ',
                element: document.querySelector('.ranking-item, .clinic-item'),
                event: 'click'
            },
            {
                name: 'Â∫óËàóÈ†ÖÁõÆ„ÇØ„É™„ÉÉ„ÇØ',
                element: document.querySelector('.store-item'),
                event: 'click'
            }
        ];

        this.metrics.interactions = {};

        for (const interaction of interactions) {
            if (interaction.element) {
                try {
                    const startTime = performance.now();
                    
                    // „Ç§„Éô„É≥„Éà„Çí„Ç∑„Éü„É•„É¨„Éº„ÉàÔºàÂÆüÈöõ„ÅÆ„Ç§„Éô„É≥„ÉàÁô∫ÁÅ´„ÅØ„Åó„Å™„ÅÑÔºâ
                    const event = new Event(interaction.event, { bubbles: true });
                    const rect = interaction.element.getBoundingClientRect();
                    
                    const endTime = performance.now();
                    const responseTime = endTime - startTime;

                    this.metrics.interactions[interaction.name] = {
                        responseTime: Math.round(responseTime * 100) / 100,
                        elementVisible: rect.width > 0 && rect.height > 0,
                        hasEventListener: interaction.element.onclick !== null ||
                                       interaction.element.onchange !== null,
                        status: responseTime < this.benchmarks.interaction ? 'PASS' : 'FAIL'
                    };

                    console.log(`  ${interaction.name}: ${responseTime.toFixed(2)}ms`);
                } catch (error) {
                    console.log(`  ${interaction.name}: ‚ùå „Ç®„É©„Éº - ${error.message}`);
                    this.metrics.interactions[interaction.name] = {
                        error: error.message,
                        status: 'ERROR'
                    };
                }
            } else {
                console.log(`  ${interaction.name}: ‚ö†Ô∏è  Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
                this.metrics.interactions[interaction.name] = {
                    status: 'NOT_FOUND'
                };
            }
        }
    }

    /**
     * 5. „É™„ÇΩ„Éº„Çπ‰ΩøÁî®ÈáèÊ∏¨ÂÆö
     */
    async measureResourceUsage() {
        console.log('üìä 5. „É™„ÇΩ„Éº„Çπ‰ΩøÁî®ÈáèÊ∏¨ÂÆö');

        const resources = performance.getEntriesByType('resource');
        
        // „Éï„Ç°„Ç§„É´„Çø„Ç§„ÉóÂà•„Å´ÂàÜÈ°û
        const resourceTypes = {
            css: resources.filter(r => r.name.includes('.css')),
            js: resources.filter(r => r.name.includes('.js')),
            images: resources.filter(r => /\.(jpg|jpeg|png|gif|svg|webp)/.test(r.name)),
            data: resources.filter(r => r.name.includes('.csv') || r.name.includes('.json')),
            other: resources.filter(r => 
                !r.name.includes('.css') && 
                !r.name.includes('.js') && 
                !/\.(jpg|jpeg|png|gif|svg|webp)/.test(r.name) &&
                !r.name.includes('.csv') &&
                !r.name.includes('.json')
            )
        };

        this.metrics.resources = {
            total: {
                count: resources.length,
                size: Math.round(resources.reduce((sum, r) => sum + (r.transferSize || 0), 0) / 1024),
                loadTime: Math.round(resources.reduce((sum, r) => sum + (r.duration || 0), 0))
            },
            css: {
                count: resourceTypes.css.length,
                size: Math.round(resourceTypes.css.reduce((sum, r) => sum + (r.transferSize || 0), 0) / 1024),
                avgLoadTime: resourceTypes.css.length > 0 ? 
                    Math.round(resourceTypes.css.reduce((sum, r) => sum + (r.duration || 0), 0) / resourceTypes.css.length) : 0
            },
            js: {
                count: resourceTypes.js.length,
                size: Math.round(resourceTypes.js.reduce((sum, r) => sum + (r.transferSize || 0), 0) / 1024),
                avgLoadTime: resourceTypes.js.length > 0 ? 
                    Math.round(resourceTypes.js.reduce((sum, r) => sum + (r.duration || 0), 0) / resourceTypes.js.length) : 0
            },
            images: {
                count: resourceTypes.images.length,
                size: Math.round(resourceTypes.images.reduce((sum, r) => sum + (r.transferSize || 0), 0) / 1024)
            },
            data: {
                count: resourceTypes.data.length,
                size: Math.round(resourceTypes.data.reduce((sum, r) => sum + (r.transferSize || 0), 0) / 1024)
            }
        };

        console.log(`  Á∑è„É™„ÇΩ„Éº„Çπ: ${this.metrics.resources.total.count}ÂÄã (${this.metrics.resources.total.size}KB)`);
        console.log(`  CSS: ${this.metrics.resources.css.count}ÂÄã (${this.metrics.resources.css.size}KB)`);
        console.log(`  JavaScript: ${this.metrics.resources.js.count}ÂÄã (${this.metrics.resources.js.size}KB)`);
        console.log(`  ÁîªÂÉè: ${this.metrics.resources.images.count}ÂÄã (${this.metrics.resources.images.size}KB)`);
        console.log(`  „Éá„Éº„Çø: ${this.metrics.resources.data.count}ÂÄã (${this.metrics.resources.data.size}KB)`);
    }

    /**
     * 6. „É°„É¢„É™‰ΩøÁî®ÈáèÊ∏¨ÂÆö
     */
    async measureMemoryUsage() {
        console.log('üìä 6. „É°„É¢„É™‰ΩøÁî®ÈáèÊ∏¨ÂÆö');

        if (performance.memory) {
            const memory = performance.memory;
            this.metrics.memory = {
                used: Math.round(memory.usedJSHeapSize / 1024 / 1024 * 100) / 100,
                total: Math.round(memory.totalJSHeapSize / 1024 / 1024 * 100) / 100,
                limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024 * 100) / 100,
                usage: Math.round(memory.usedJSHeapSize / memory.jsHeapSizeLimit * 100),
                status: memory.usedJSHeapSize / memory.jsHeapSizeLimit < this.benchmarks.memory ? 'PASS' : 'WARN'
            };

            console.log(`  ‰ΩøÁî®‰∏≠: ${this.metrics.memory.used}MB`);
            console.log(`  Ââ≤„ÇäÂΩì„Å¶Ê∏à„Åø: ${this.metrics.memory.total}MB`);
            console.log(`  Âà∂Èôê: ${this.metrics.memory.limit}MB`);
            console.log(`  ‰ΩøÁî®Áéá: ${this.metrics.memory.usage}%`);
        } else {
            console.log('  ‚ö†Ô∏è  Memory APIÂà©Áî®‰∏çÂèØ');
            this.metrics.memory = { available: false };
        }
    }

    /**
     * First Contentful PaintÂèñÂæó
     */
    getFirstContentfulPaint() {
        const fcpEntry = performance.getEntriesByName('first-contentful-paint')[0];
        return fcpEntry ? Math.round(fcpEntry.startTime) : null;
    }

    /**
     * Largest Contentful PaintÂèñÂæó
     */
    getLargestContentfulPaint() {
        return new Promise((resolve) => {
            if ('PerformanceObserver' in window) {
                const observer = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    if (entries.length > 0) {
                        const lcp = entries[entries.length - 1];
                        resolve(Math.round(lcp.startTime));
                        observer.disconnect();
                    }
                });
                observer.observe({ entryTypes: ['largest-contentful-paint'] });
                
                // 3ÁßíÂæå„Å´„Çø„Ç§„É†„Ç¢„Ç¶„Éà
                setTimeout(() => {
                    observer.disconnect();
                    resolve(null);
                }, 3000);
            } else {
                resolve(null);
            }
        });
    }

    /**
     * „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É¨„Éù„Éº„ÉàÁîüÊàê
     */
    generatePerformanceReport() {
        console.log('\n' + '='.repeat(50));
        console.log('üìã „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É¨„Éù„Éº„Éà');
        console.log('='.repeat(50));

        // Á∑èÂêàË©ï‰æ°
        let score = 100;
        let issues = [];

        // „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøË©ï‰æ°
        if (this.metrics.pageLoad.totalLoad) {
            if (this.metrics.pageLoad.totalLoad > this.benchmarks.pageLoad) {
                score -= 20;
                issues.push(`„Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊôÇÈñì„ÅåÈï∑„ÅÑ (${this.metrics.pageLoad.totalLoad}ms > ${this.benchmarks.pageLoad}ms)`);
            }
            if (this.metrics.pageLoad.fcp > 2500) {
                score -= 10;
                issues.push(`First Contentful Paint„ÅåÈÅÖ„ÅÑ (${this.metrics.pageLoad.fcp}ms)`);
            }
            if (this.metrics.pageLoad.lcp > 4000) {
                score -= 15;
                issues.push(`Largest Contentful Paint„ÅåÈÅÖ„ÅÑ (${this.metrics.pageLoad.lcp}ms)`);
            }
        }

        // „Çª„ÇØ„Ç∑„Éß„É≥Ë°®Á§∫Ë©ï‰æ°
        const slowSections = Object.entries(this.metrics.sectionRender)
            .filter(([_, data]) => data.status === 'FAIL');
        if (slowSections.length > 0) {
            score -= slowSections.length * 5;
            issues.push(`„Çª„ÇØ„Ç∑„Éß„É≥Ë°®Á§∫„ÅåÈÅÖ„ÅÑ (${slowSections.length}ÂÄã)`);
        }

        // „Éá„Éº„ÇøË™≠„ÅøËæº„ÅøË©ï‰æ°
        const slowDataLoads = Object.entries(this.metrics.dataLoading)
            .filter(([_, data]) => data.status === 'FAIL');
        if (slowDataLoads.length > 0) {
            score -= slowDataLoads.length * 8;
            issues.push(`„Éá„Éº„ÇøË™≠„ÅøËæº„Åø„ÅåÈÅÖ„ÅÑ (${slowDataLoads.length}„Éï„Ç°„Ç§„É´)`);
        }

        // „É™„ÇΩ„Éº„Çπ‰ΩøÁî®ÈáèË©ï‰æ°
        if (this.metrics.resources.total.count > 30) {
            score -= 10;
            issues.push(`„É™„ÇΩ„Éº„ÇπÊï∞„ÅåÂ§ö„ÅÑ (${this.metrics.resources.total.count}ÂÄã)`);
        }
        if (this.metrics.resources.total.size > 1000) {
            score -= 15;
            issues.push(`Á∑è„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅåÂ§ß„Åç„ÅÑ (${this.metrics.resources.total.size}KB)`);
        }

        // „É°„É¢„É™‰ΩøÁî®ÈáèË©ï‰æ°
        if (this.metrics.memory.status === 'WARN') {
            score -= 10;
            issues.push(`„É°„É¢„É™‰ΩøÁî®Áéá„ÅåÈ´ò„ÅÑ (${this.metrics.memory.usage}%)`);
        }

        score = Math.max(0, score);

        console.log(`üéØ Á∑èÂêà„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Çπ„Ç≥„Ç¢: ${score}/100`);
        
        if (score >= 90) {
            console.log('üü¢ ÂÑ™ÁßÄ - „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Å´ÂïèÈ°å„Å™„Åó');
        } else if (score >= 75) {
            console.log('üü° ËâØÂ•Ω - ËªΩÂæÆ„Å™ÊúÄÈÅ©Âåñ„ÅåÊé®Â•®');
        } else if (score >= 60) {
            console.log('üü† Ë¶ÅÊîπÂñÑ - „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ„ÅåÂøÖË¶Å');
        } else {
            console.log('üî¥ ‰∏çÂêàÊ†º - ÈáçÂ§ß„Å™„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂïèÈ°å');
        }

        // ÊîπÂñÑÁÇπ
        if (issues.length > 0) {
            console.log('\n‚ö†Ô∏è  ÊîπÂñÑÁÇπ:');
            issues.forEach((issue, index) => {
                console.log(`   ${index + 1}. ${issue}`);
            });
        }

        // Êé®Â•®‰∫ãÈ†Ö
        console.log('\nüí° Êé®Â•®‰∫ãÈ†Ö:');
        if (this.metrics.pageLoad.totalLoad > 2000) {
            console.log('   - ÁîªÂÉè„ÅÆÊúÄÈÅ©ÂåñÔºàÂúßÁ∏Æ„ÄÅWebPÂΩ¢Âºè„ÅÆ‰ΩøÁî®Ôºâ');
            console.log('   - CSS/JS„Éï„Ç°„Ç§„É´„ÅÆÂúßÁ∏Æ„ÉªÁµ±Âêà');
        }
        if (this.metrics.resources.total.count > 20) {
            console.log('   - „É™„ÇΩ„Éº„Çπ„ÅÆÁµ±ÂêàÔºàCSS/JS„Éï„Ç°„Ç§„É´„ÅÆ„Éê„É≥„Éâ„É´Ôºâ');
        }
        if (slowDataLoads.length > 0) {
            console.log('   - CSV„Éï„Ç°„Ç§„É´„ÅÆËªΩÈáèÂåñ');
            console.log('   - „Éá„Éº„Çø„ÅÆÈÅÖÂª∂Ë™≠„ÅøËæº„ÅøÔºàLazy LoadingÔºâ');
        }
        if (this.metrics.memory.usage > 70) {
            console.log('   - „É°„É¢„É™„É™„Éº„ÇØ„ÅÆË™øÊüª');
            console.log('   - DOM„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÅÆÈÅ©Âàá„Å™ÂâäÈô§');
        }

        console.log('='.repeat(50));

        // „Ç∞„É≠„Éº„Éê„É´„Çπ„Ç≥„Éº„Éó„Å´ÁµêÊûú„Çí‰øùÂ≠ò
        window.performanceTestResults = {
            score,
            metrics: this.metrics,
            issues,
            timestamp: new Date().toISOString()
        };
    }
}

// Ëá™ÂãïÂÆüË°åÔºà„Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÂÆå‰∫ÜÂæåÔºâ
document.addEventListener('DOMContentLoaded', async () => {
    setTimeout(async () => {
        const tester = new PerformanceTester();
        await tester.runPerformanceTests();
    }, 2000); // 2ÁßíÂæÖ„Å£„Å¶„Åã„ÇâÂÆüË°å
});

// „Ç∞„É≠„Éº„Éê„É´„Çπ„Ç≥„Éº„Éó„Åß„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ„Å´„Åô„Çã
window.PerformanceTester = PerformanceTester;

// ÊâãÂãïÂÆüË°åÁî®Èñ¢Êï∞
window.runPerformanceTest = async () => {
    const tester = new PerformanceTester();
    return await tester.runPerformanceTests();
};